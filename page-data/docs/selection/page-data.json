{"componentChunkName":"component---src-templates-doc-js","path":"/docs/selection","webpackCompilationHash":"8306eb02070f1ea9be84","result":{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Selection"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There is a "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/Autodesk/react-base-table/pull/39"},"children":[{"type":"text","value":"PR"}]},{"type":"text","value":" to add selection feature, but I don't want to merge it with "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/Autodesk/react-base-table/pull/39#pullrequestreview-241987600"},"children":[{"type":"text","value":"good reasons"}]},{"type":"text","value":", so I'd like to share a recipe here for reference"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Recipe"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-jsx"]},"children":[{"type":"text","value":"const StyledTable = styled(BaseTable)`\n  .row-selected {\n    background-color: #e3e3e3;\n  }\n`;\n\nclass SelectionCell extends React.PureComponent {\n  _handleChange = e => {\n    const { rowData, rowIndex, column } = this.props;\n    const { onChange } = column;\n\n    onChange({ selected: e.target.checked, rowData, rowIndex });\n  };\n\n  render() {\n    const { rowData, column } = this.props;\n    const { selectedRowKeys, rowKey } = column;\n    const checked = selectedRowKeys.includes(rowData[rowKey]);\n\n    return <input type=\"checkbox\" checked={checked} onChange={this._handleChange} />;\n  }\n}\n\nclass SelectableTable extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    const { selectedRowKeys, defaultSelectedRowKeys, expandedRowKeys, defaultExpandedRowKeys } = props;\n    this.state = {\n      selectedRowKeys: (selectedRowKeys !== undefined ? selectedRowKeys : defaultSelectedRowKeys) || [],\n      expandedRowKeys: (expandedRowKeys !== undefined ? expandedRowKeys : defaultExpandedRowKeys) || [],\n    };\n  }\n\n  /**\n   * Set `selectedRowKeys` manually.\n   * This method is available only if `selectedRowKeys` is uncontrolled.\n   *\n   * @param {array} selectedRowKeys\n   */\n  setSelectedRowKeys(selectedRowKeys) {\n    // if `selectedRowKeys` is controlled\n    if (this.props.selectedRowKeys !== undefined) return;\n\n    this.setState({\n      selectedRowKeys: cloneArray(selectedRowKeys),\n    });\n  }\n\n  /**\n   * See BaseTable#setExpandedRowKeys\n   */\n  setExpandedRowKeys(expandedRowKeys) {\n    // if `expandedRowKeys` is controlled\n    if (this.props.expandedRowKeys !== undefined) return;\n\n    this.setState({\n      expandedRowKeys: cloneArray(expandedRowKeys),\n    });\n  }\n\n  /* some other custom methods and proxy methods */\n\n  /**\n   * Remove rowKeys from inner state  manually, it's useful to purge dirty state after rows removed.\n   * This method is available only if `selectedRowKeys` or `expandedRowKeys` is uncontrolled.\n   *\n   * @param {array} rowKeys\n   */\n  removeRowKeysFromState(rowKeys) {\n    if (!Array.isArray(rowKeys)) return;\n\n    const state = {};\n    if (this.props.selectedRowKeys === undefined && this.state.selectedRowKeys.length > 0) {\n      state.selectedRowKeys = this.state.selectedRowKeys.filter(key => !rowKeys.includes(key));\n    }\n    if (this.props.expandedRowKeys === undefined && this.state.expandedRowKeys.length > 0) {\n      state.expandedRowKeys = this.state.expandedRowKeys.filter(key => !rowKeys.includes(key));\n    }\n    if (state.selectedRowKeys || state.expandedRowKeys) {\n      this.setState(state);\n    }\n  }\n\n  _handleSelectChange = ({ selected, rowData, rowIndex }) => {\n    const selectedRowKeys = [...this.state.selectedRowKeys];\n    const key = rowData[this.props.rowKey];\n\n    if (selected) {\n      if (!selectedRowKeys.includes(key)) selectedRowKeys.push(key);\n    } else {\n      const index = selectedRowKeys.indexOf(key);\n      if (index > -1) {\n        selectedRowKeys.splice(index, 1);\n      }\n    }\n\n    // if `selectedRowKeys` is uncontrolled, update internal state\n    if (this.props.selectedRowKeys === undefined) {\n      this.setState({ selectedRowKeys });\n    }\n    this.props.onRowSelect({ selected, rowData, rowIndex });\n    this.props.onSelectedRowsChange(selectedRowKeys);\n  };\n\n  _rowClassName = ({ rowData, rowIndex }) => {\n    const { rowClassName, rowKey } = this.props;\n    const { selectedRowKeys } = this.state;\n\n    const rowClass = rowClassName ? callOrReturn(rowClassName, { rowData, rowIndex }) : '';\n    const key = rowData[rowKey];\n\n    return [rowClass, selectedRowKeys.includes(key) && 'row-selected'].filter(Boolean).concat(' ');\n  };\n\n  render() {\n    const { columns, children, selectable, selectionColumnProps, ...rest } = this.props;\n    const { selectedRowKeys } = this.state;\n\n    // you'd better memoize this operation\n    let _columns = columns || normalizeColumns(children);\n    if (selectable) {\n      const selectionColumn = {\n        width: 40,\n        flexShrink: 0,\n        resizable: false,\n        frozen: Column.FrozenDirection.LEFT,\n        cellRenderer: SelectionCell,\n        ...selectionColumnProps,\n        key: '__selection__',\n        rowKey: this.props.rowKey,\n        selectedRowKeys: selectedRowKeys,\n        onChange: this._handleSelectChange,\n      };\n      _columns = [selectionColumn, ..._columns];\n    }\n\n    return <StyledTable {...rest} columns={_columns} rowClassName={this._rowClassName} />;\n  }\n}\n\nSelectableTable.defaultProps = {\n  ...BaseTable.defaultProps,\n  onRowSelect: noop,\n  onSelectedRowsChange: noop,\n};\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Playground"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-jsx"],"dataMeta":"live editorHeight=400"},"children":[{"type":"text","value":"const StyledTable = styled(BaseTable)`\n  .row-selected {\n    background-color: #e3e3e3;\n  }\n`;\n\nclass SelectionCell extends React.PureComponent {\n  _handleChange = e => {\n    const { rowData, rowIndex, column } = this.props;\n    const { onChange } = column;\n\n    onChange({ selected: e.target.checked, rowData, rowIndex });\n  };\n\n  render() {\n    const { rowData, column } = this.props;\n    const { selectedRowKeys, rowKey } = column;\n    const checked = selectedRowKeys.includes(rowData[rowKey]);\n\n    return <input type=\"checkbox\" checked={checked} onChange={this._handleChange} />;\n  }\n}\n\nclass SelectableTable extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    const { selectedRowKeys, defaultSelectedRowKeys, expandedRowKeys, defaultExpandedRowKeys } = props;\n    this.state = {\n      selectedRowKeys: (selectedRowKeys !== undefined ? selectedRowKeys : defaultSelectedRowKeys) || [],\n      expandedRowKeys: (expandedRowKeys !== undefined ? expandedRowKeys : defaultExpandedRowKeys) || [],\n    };\n  }\n\n  /**\n   * Set `selectedRowKeys` manually.\n   * This method is available only if `selectedRowKeys` is uncontrolled.\n   *\n   * @param {array} selectedRowKeys\n   */\n  setSelectedRowKeys(selectedRowKeys) {\n    // if `selectedRowKeys` is controlled\n    if (this.props.selectedRowKeys !== undefined) return;\n\n    this.setState({\n      selectedRowKeys: cloneArray(selectedRowKeys),\n    });\n  }\n\n  /**\n   * See BaseTable#setExpandedRowKeys\n   */\n  setExpandedRowKeys(expandedRowKeys) {\n    // if `expandedRowKeys` is controlled\n    if (this.props.expandedRowKeys !== undefined) return;\n\n    this.setState({\n      expandedRowKeys: cloneArray(expandedRowKeys),\n    });\n  }\n\n  /* some other custom methods and proxy methods */\n\n  /**\n   * Remove rowKeys from inner state  manually, it's useful to purge dirty state after rows removed.\n   * This method is available only if `selectedRowKeys` or `expandedRowKeys` is uncontrolled.\n   *\n   * @param {array} rowKeys\n   */\n  removeRowKeysFromState(rowKeys) {\n    if (!Array.isArray(rowKeys)) return;\n\n    const state = {};\n    if (this.props.selectedRowKeys === undefined && this.state.selectedRowKeys.length > 0) {\n      state.selectedRowKeys = this.state.selectedRowKeys.filter(key => !rowKeys.includes(key));\n    }\n    if (this.props.expandedRowKeys === undefined && this.state.expandedRowKeys.length > 0) {\n      state.expandedRowKeys = this.state.expandedRowKeys.filter(key => !rowKeys.includes(key));\n    }\n    if (state.selectedRowKeys || state.expandedRowKeys) {\n      this.setState(state);\n    }\n  }\n\n  _handleSelectChange = ({ selected, rowData, rowIndex }) => {\n    const selectedRowKeys = [...this.state.selectedRowKeys];\n    const key = rowData[this.props.rowKey];\n\n    if (selected) {\n      if (!selectedRowKeys.includes(key)) selectedRowKeys.push(key);\n    } else {\n      const index = selectedRowKeys.indexOf(key);\n      if (index > -1) {\n        selectedRowKeys.splice(index, 1);\n      }\n    }\n\n    // if `selectedRowKeys` is uncontrolled, update internal state\n    if (this.props.selectedRowKeys === undefined) {\n      this.setState({ selectedRowKeys });\n    }\n    this.props.onRowSelect({ selected, rowData, rowIndex });\n    this.props.onSelectedRowsChange(selectedRowKeys);\n  };\n\n  _rowClassName = ({ rowData, rowIndex }) => {\n    const { rowClassName, rowKey } = this.props;\n    const { selectedRowKeys } = this.state;\n\n    const rowClass = rowClassName ? callOrReturn(rowClassName, { rowData, rowIndex }) : '';\n    const key = rowData[rowKey];\n\n    return [rowClass, selectedRowKeys.includes(key) && 'row-selected'].filter(Boolean).concat(' ');\n  };\n\n  render() {\n    const { columns, children, selectable, selectionColumnProps, ...rest } = this.props;\n    const { selectedRowKeys } = this.state;\n\n    // you'd better memoize this operation\n    let _columns = columns || normalizeColumns(children);\n    if (selectable) {\n      const selectionColumn = {\n        width: 40,\n        flexShrink: 0,\n        resizable: false,\n        frozen: Column.FrozenDirection.LEFT,\n        cellRenderer: SelectionCell,\n        ...selectionColumnProps,\n        key: '__selection__',\n        rowKey: this.props.rowKey,\n        selectedRowKeys: selectedRowKeys,\n        onChange: this._handleSelectChange,\n      };\n      _columns = [selectionColumn, ..._columns];\n    }\n\n    return <StyledTable {...rest} columns={_columns} rowClassName={this._rowClassName} />;\n  }\n}\n\nSelectableTable.defaultProps = {\n  ...BaseTable.defaultProps,\n  onRowSelect: noop,\n  onSelectedRowsChange: noop,\n};\n\n// Use case\nconst columns = generateColumns(10);\nconst data = generateData(columns, 200);\n\nexport default () => (\n  <SelectableTable\n    width={700}\n    height={400}\n    selectable\n    columns={columns}\n    data={data}\n    onRowSelect={action('onRowSelect')}\n    onSelectedRowsChange={action('onSelectedRowsChange')}\n  />\n);\n"}]}]}],"data":{"quirksMode":false}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/docs/selection"}}}